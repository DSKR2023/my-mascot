<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Desktop Mascot - Official Site</title>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #87CEEB;
            --accent-color: #FFD700;
            --pink-color: #FFD1DC;
            --text-color: #333;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; touch-action: manipulation;
            -webkit-font-smoothing: antialiased;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #f8f9fa;
        }

        #mascotCanvas { position: fixed; top: 0; left: 0; z-index: 1; }

        .ui-layer {
            position: relative; z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; pointer-events: none;
        }

        .logo-title { margin-bottom: 2rem; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.1)); }
        .logo-title h1 {
            margin: 0; font-size: 3.2rem; font-weight: 900;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color), var(--pink-color), var(--primary-color));
            background-size: 200% auto; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: gradientAnim 6s linear infinite; -webkit-text-stroke: 1px white;
        }

        @keyframes gradientAnim { to { background-position: 200% center; } }

        .button-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; pointer-events: auto;
        }

        .btn {
            background: white; border: 2.5px solid var(--primary-color);
            padding: 12px 20px; border-radius: 12px; font-size: 0.95rem; font-weight: 800;
            cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 0 var(--primary-color);
        }
        .btn:hover { transform: translateY(2px); box-shadow: 0 2px 0 var(--primary-color); background: #f0faff; }
        
        .btn-game { border-color: #9370DB; box-shadow: 0 4px 0 #9370DB; color: #9370DB; grid-column: span 2; font-size: 1.1rem; }
        .btn-game:hover { background: #f3efff; }

        /* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€š */
        .modal {
            display: none; position: fixed; z-index: 100;
            left: 0; top: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(4px);
        }
        .modal-content {
            background: white; margin: 5vh auto; padding: 30px; border-radius: 20px;
            width: 90%; max-width: 500px; max-height: 85vh; overflow-y: auto;
            position: relative; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .close-btn { position: absolute; right: 20px; top: 10px; font-size: 30px; cursor: pointer; color: #ccc; z-index: 101; }

        /* ã‚²ãƒ¼ãƒ ç”»é¢å°‚ç”¨ */
        #gameContainer {
            width: 100%; height: 450px; background: #eee; border: 4px solid #333;
            position: relative; overflow: hidden; touch-action: none;
        }
        #gameCanvas { background: #fff; display: block; margin: 0 auto; }
        .game-ui { display: flex; justify-content: space-between; margin-bottom: 10px; font-weight: bold; }
        .rule-btn { background: #eee; border: 1px solid #ccc; padding: 2px 10px; border-radius: 5px; cursor: pointer; }

        footer { position: absolute; bottom: 15px; width: 100%; text-align: center; z-index: 10; font-size: 0.75rem; color: #888; pointer-events: auto; }
        footer a { color: var(--primary-color); text-decoration: none; }
    </style>
</head>
<body>

    <canvas id="mascotCanvas"></canvas>

    <div class="ui-layer">
        <div class="logo-title"><h1>Desktop Mascot</h1></div>
        <div class="button-grid">
            <button class="btn btn-game" onclick="openGame()">ğŸ® ã‚²ãƒ¼ãƒ åºƒå ´ï¼ˆã‚­ãƒ¥ãƒ¼ãƒ–é€²åŒ–ï¼‰</button>
            <button class="btn" onclick="openModal('howToUseModal')">ğŸ“– ä½¿ç”¨æ–¹æ³•</button>
            <button class="btn" onclick="openModal('termsModal')">ğŸ“œ åˆ©ç”¨è¦ç´„</button>
            <button class="btn" onclick="openModal('privacyModal')">ğŸ”’ ç§˜å¯†ä¿æŒ</button>
            <button class="btn" onclick="openModal('downloadModal')">ğŸ“¥ å–å¾—</button>
        </div>
    </div>

    <footer>made by Jumu Tinora(DSKR) | <a href="https://dskr-home.vercel.app/#home" target="_blank">ã‚µãƒ¼ã‚¯ãƒ«å…¬å¼HP</a></footer>

    <div id="gameModal" class="modal">
        <div class="modal-content" style="max-width: 400px; padding: 20px;">
            <span class="close-btn" onclick="closeGame()">&times;</span>
            <div class="game-ui">
                <span>ã‚¹ã‚³ã‚¢: <span id="scoreVal">0</span></span>
                <button class="rule-btn" onclick="alert('ã€ãƒ«ãƒ¼ãƒ«ã€‘\nåŒã˜ç¨®é¡ã®ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’ã¶ã¤ã‘ã¦é€²åŒ–ã•ã›ã‚ˆã†ï¼\nä¸€ç•ªå¤§ãã„ç‹æ§˜ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’ç›®æŒ‡ã—ã¦ã­ã€‚\nä¸Šã®ç·šã‚’è¶…ãˆãŸã‚‰ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼\n\nã€æ“ä½œã€‘\nPC: å·¦å³ã‚­ãƒ¼ ã¾ãŸã¯ A/Dã‚­ãƒ¼ã§ç§»å‹•ã€ã‚¯ãƒªãƒƒã‚¯ã§è½ã¨ã™\nã‚¹ãƒãƒ›: ã‚¿ãƒƒãƒ—ã—ãŸå ´æ‰€ã«è½ã¨ã™')">Rule</button>
            </div>
            <div id="gameContainer">
                <canvas id="gameCanvas"></canvas>
            </div>
            <p style="font-size: 0.8rem; text-align: center; margin-top: 10px; color: #666;">â€»PCã¯ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã€ã‚¹ãƒãƒ›ã¯ã‚¿ãƒƒãƒ—ã§æ“ä½œï¼</p>
        </div>
    </div>

    <div id="howToUseModal" class="modal" onclick="closeModalOnOuter(event)"><div class="modal-content"><span class="close-btn" onclick="closeModal('howToUseModal')">&times;</span><h2>ä½¿ç”¨æ–¹æ³•</h2><p>DesktopMascot.exeã‚’èµ·å‹•ã—ã¦ã€ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã§AIãƒã‚¹ã‚³ãƒƒãƒˆã¨ä¸€ç·’ã«éã”ã—ã¾ã—ã‚‡ã†ã€‚èƒŒæ™¯ã®ã‚­ãƒ¥ãƒ¼ãƒ–ã¯ãƒ‰ãƒ©ãƒƒã‚°ã§éŠã¹ã¾ã™ã€‚</p></div></div>
    <div id="termsModal" class="modal" onclick="closeModalOnOuter(event)"><div class="modal-content"><span class="close-btn" onclick="closeModal('termsModal')">&times;</span><h2>åˆ©ç”¨è¦ç´„</h2><p>äºŒæ¬¡é…å¸ƒç¦æ­¢ã€‚æ”¹é€ ã¯è‡ªç”±ã§ã™ãŒè‡ªä½œç™ºè¨€ã¯æ§ãˆã¦ãã ã•ã„ã€‚</p></div></div>
    <div id="privacyModal" class="modal" onclick="closeModalOnOuter(event)"><div class="modal-content"><span class="close-btn" onclick="closeModal('privacyModal')">&times;</span><h2>ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼</h2><p>å€‹äººãƒ‡ãƒ¼ã‚¿ã¯PCå†…ã®ã¿ã«ä¿å­˜ã•ã‚Œã€é€ä¿¡ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p></div></div>
    <div id="downloadModal" class="modal" onclick="closeModalOnOuter(event)"><div class="modal-content"><span class="close-btn" onclick="closeModal('downloadModal')">&times;</span><h2>ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</h2><p>ç¾åœ¨æº–å‚™ä¸­ã§ã™ã€‚BOOTHã§ã®å…¬é–‹ã‚’ãŠå¾…ã¡ãã ã•ã„ã€‚</p></div></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        // --- åŸºæœ¬UIåˆ¶å¾¡ ---
        function openModal(id) { document.getElementById(id).style.display = "block"; }
        function closeModal(id) { document.getElementById(id).style.display = "none"; }
        function closeModalOnOuter(event) { if (event.target.className === "modal") event.target.style.display = "none"; }
        window.addEventListener('keydown', (e) => { if (e.key === "Escape") document.querySelectorAll('.modal').forEach(m => m.style.display = "none"); });

        // --- èƒŒæ™¯ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå‰å›ã®å†…å®¹ã‚’ç¶™æ‰¿ï¼‰ ---
        const bCanvas = document.getElementById('mascotCanvas');
        const bCtx = bCanvas.getContext('2d');
        let backCubes = [];
        function bResize() { bCanvas.width = window.innerWidth; bCanvas.height = window.innerHeight; }
        window.addEventListener('resize', bResize); bResize();
        class BackCube {
            constructor() { this.init(); this.y = Math.random() * bCanvas.height; }
            init() {
                this.size = 40 + Math.random() * 40; this.x = Math.random() * bCanvas.width; this.y = -100;
                this.speedY = 0.05 + Math.random() * 0.1; this.rotation = Math.random() * 6; this.rotSpeed = (Math.random()-0.5)*0.002;
                this.color = ["#87CEEB", "#FFD700", "#FFD1DC", "#E0FFFF"][Math.floor(Math.random()*4)];
            }
            update() { this.y += this.speedY; this.rotation += this.rotSpeed; if (this.y > bCanvas.height + 50) this.init(); }
            draw() {
                bCtx.save(); bCtx.translate(this.x, this.y); bCtx.rotate(this.rotation);
                bCtx.fillStyle = this.color; bCtx.strokeStyle = "#333"; bCtx.beginPath();
                bCtx.roundRect(-this.size/2, -this.size/2, this.size, this.size, 5); bCtx.fill(); bCtx.stroke(); bCtx.restore();
            }
        }
        for(let i=0; i<15; i++) backCubes.push(new BackCube());
        function bAnimate() { bCtx.clearRect(0,0,bCanvas.width,bCanvas.height); backCubes.forEach(c => {c.update(); c.draw();}); requestAnimationFrame(bAnimate); }
        bAnimate();

        // --- ã‚­ãƒ¥ãƒ¼ãƒ–é€²åŒ–ã‚²ãƒ¼ãƒ  (Suika Game Style) ---
        let engine, render, runner;
        let gameActive = false;
        let currentCube = null;
        let score = 0;
        const gameWidth = 320;
        const gameHeight = 450;
        
        // é€²åŒ–ãƒ‡ãƒ¼ã‚¿ï¼ˆ7ç¨®é¡ï¼‰
        const CUBE_TYPES = [
            { size: 15, color: "#E0FFFF", label: "çœ ", expr: 1, score: 2 },
            { size: 25, color: "#87CEEB", label: "æ™®", expr: 0, score: 4 },
            { size: 35, color: "#FFD1DC", label: "ç…§", expr: 2, score: 8 },
            { size: 45, color: "#FFD700", label: "é©š", expr: 3, score: 16 },
            { size: 60, color: "#9370DB", label: "å‡›", expr: 0, score: 32 },
            { size: 80, color: "#32CD32", label: "å¹¸", expr: 0, score: 64 },
            { size: 100, color: "#FF4500", label: "ç‹", expr: 0, score: 128 }
        ];

        function openGame() {
            document.getElementById('gameModal').style.display = "block";
            if (!engine) initGame();
            gameActive = true;
            score = 0;
            updateScore(0);
        }

        function closeGame() {
            document.getElementById('gameModal').style.display = "none";
            gameActive = false;
        }

        function initGame() {
            const { Engine, Render, Runner, World, Bodies, Events } = Matter;
            engine = Engine.create();
            const container = document.getElementById('gameContainer');
            const canvas = document.getElementById('gameCanvas');
            
            render = Render.create({
                element: container,
                engine: engine,
                canvas: canvas,
                options: {
                    width: gameWidth,
                    height: gameHeight,
                    wireframes: false,
                    background: '#ffffff'
                }
            });

            // å£ã®ä½œæˆ
            const wallOptions = { isStatic: true, render: { fillStyle: '#333' } };
            World.add(engine.world, [
                Bodies.rectangle(gameWidth/2, gameHeight + 10, gameWidth, 20, wallOptions), // åºŠ
                Bodies.rectangle(-10, gameHeight/2, 20, gameHeight, wallOptions), // å·¦
                Bodies.rectangle(gameWidth + 10, gameHeight/2, 20, gameHeight, wallOptions) // å³
            ]);

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);

            // åˆä½“åˆ¤å®š
            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach((pair) => {
                    const { bodyA, bodyB } = pair;
                    if (bodyA.label === bodyB.label && bodyA.label.startsWith('cube_')) {
                        const typeIndex = parseInt(bodyA.label.split('_')[1]);
                        if (typeIndex < CUBE_TYPES.length - 1) {
                            const newX = (bodyA.position.x + bodyB.position.x) / 2;
                            const newY = (bodyA.position.y + bodyB.position.y) / 2;
                            
                            World.remove(engine.world, [bodyA, bodyB]);
                            spawnCube(newX, newY, typeIndex + 1, false);
                            updateScore(CUBE_TYPES[typeIndex+1].score);
                        }
                    }
                });
            });

            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
            Events.on(engine, 'afterUpdate', () => {
                if (!gameActive) return;
                engine.world.bodies.forEach(body => {
                    if (!body.isStatic && body.position.y < 50 && body !== currentCube) {
                        gameActive = false;
                        alert("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ ã‚¹ã‚³ã‚¢: " + score);
                        resetGame();
                    }
                });
            });

            createNextCube();

            // æ“ä½œã‚¤ãƒ™ãƒ³ãƒˆ
            container.addEventListener('click', (e) => { if(gameActive) dropCube(); });
            window.addEventListener('keydown', (e) => {
                if (!gameActive || !currentCube) return;
                if (e.key === 'ArrowLeft' || e.key === 'a') moveCurrent(-15);
                if (e.key === 'ArrowRight' || e.key === 'd') moveCurrent(15);
                if (e.key === ' ') dropCube();
            });
            // ã‚¹ãƒãƒ›ã‚¿ãƒƒãƒ—æ“ä½œç”¨
            container.addEventListener('touchstart', (e) => {
                if(!gameActive) return;
                const rect = container.getBoundingClientRect();
                const touchX = e.touches[0].clientX - rect.left;
                Matter.Body.setPosition(currentCube, { x: Math.max(20, Math.min(gameWidth-20, touchX)), y: 30 });
                dropCube();
            });
        }

        function createNextCube() {
            if (!gameActive) return;
            const typeIndex = Math.floor(Math.random() * 3); // æœ€åˆã¯å°ã•ã„ã®3ç¨®ã‹ã‚‰
            currentCube = spawnCube(gameWidth/2, 30, typeIndex, true);
        }

        function spawnCube(x, y, index, isStatic) {
            const type = CUBE_TYPES[index];
            const cube = Matter.Bodies.rectangle(x, y, type.size, type.size, {
                friction: 0.5,
                restitution: 0.2,
                label: 'cube_' + index,
                isStatic: isStatic,
                render: {
                    fillStyle: type.color,
                    strokeStyle: '#333',
                    lineWidth: 2
                }
            });
            Matter.World.add(engine.world, cube);
            return cube;
        }

        function moveCurrent(dx) {
            const newX = Math.max(20, Math.min(gameWidth - 20, currentCube.position.x + dx));
            Matter.Body.setPosition(currentCube, { x: newX, y: 30 });
        }

        function dropCube() {
            if (!currentCube || !currentCube.isStatic) return;
            Matter.Body.setStatic(currentCube, false);
            const dropped = currentCube;
            currentCube = null;
            setTimeout(() => { if(gameActive) createNextCube(); }, 800);
        }

        function updateScore(points) {
            score += points;
            document.getElementById('scoreVal').innerText = score;
        }

        function resetGame() {
            Matter.World.clear(engine.world, true);
            score = 0;
            updateScore(0);
            createNextCube();
            gameActive = true;
        }
    </script>
</body>
</html>
