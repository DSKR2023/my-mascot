<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <meta name="google-site-verification" content="UxS24-MHBRyrQe_3JMQn93MPSRk9jXnWQxgyrjnm-gc" />

    <title>Desktop Mascot - Official Site</title>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #87CEEB;
            --accent-color: #FFD700;
            --pink-color: #FFD1DC;
            --text-color: #333;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; touch-action: manipulation;
            -webkit-font-smoothing: antialiased;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #f8f9fa;
        }

        #mascotCanvas { position: fixed; top: 0; left: 0; z-index: 1; cursor: default; width: 100%; height: 100%; }

        .ui-layer {
            position: relative; z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; pointer-events: none;
        }

        .logo-title { margin-bottom: 2rem; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.1)); }
        .logo-title h1 {
            margin: 0; font-size: 3.5rem; font-weight: 900;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color), var(--pink-color), var(--primary-color));
            background-size: 200% auto; -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientAnim 6s linear infinite; -webkit-text-stroke: 1px white;
            paint-order: stroke fill;
        }

        @keyframes gradientAnim { to { background-position: 200% center; } }

        .button-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; pointer-events: auto;
        }

        .btn {
            background: white; border: 2.5px solid var(--primary-color);
            padding: 14px 25px; border-radius: 12px; font-size: 1rem; font-weight: 800;
            color: var(--text-color); cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 0 var(--primary-color);
            font-family: 'M PLUS Rounded 1c', sans-serif;
            text-decoration: none; display: flex; justify-content: center; align-items: center; box-sizing: border-box;
        }
        .btn:hover { transform: translateY(2px); box-shadow: 0 2px 0 var(--primary-color); background: #f0faff; }
        
        .btn-game { border-color: #9370DB; box-shadow: 0 4px 0 #9370DB; color: #9370DB; grid-column: span 2; font-size: 1.1rem; }
        .btn-game:hover { background: #f3efff; }

        .modal {
            display: none; position: fixed; z-index: 100;
            left: 0; top: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(4px);
            justify-content: center; align-items: center;
        }
        .modal-content {
            background: white; padding: 25px; border-radius: 25px;
            width: 90%; max-width: 420px; max-height: 95vh; overflow-y: auto; overflow-x: hidden;
            position: relative; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            box-sizing: border-box;
        }

        #gameContainer {
            width: fit-content; max-width: 100%; height: 500px;
            margin: 0 auto; background: #fff; border: 4px solid #333;
            border-radius: 10px; position: relative; overflow: hidden; touch-action: none;
            box-sizing: content-box;
        }
        #gameCanvas { display: block; max-width: 100%; height: auto; margin: 0 auto; }
        
        .game-ui { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
        .score-box { font-size: 1.2rem; font-weight: 900; color: #333; }
        .rule-btn { background: #f0f0f0; border: 2px solid #ddd; padding: 4px 12px; border-radius: 8px; cursor: pointer; font-weight: bold; font-family: inherit; }
        .collection-btn { background: #FFFACD; border-color: #FFD700; color: #B8860B; margin-left: 5px; }
        .collection-btn:hover { background: #FFF0F5; border-color: #FF69B4; color: #FF1493; }

        .game-close-btn {
            display: block; width: fit-content; margin: 15px auto 5px;
            background: transparent; border: none; color: #aaa;
            font-size: 1.1rem; font-weight: bold; cursor: pointer;
            transition: 0.3s; pointer-events: auto;
        }
        .game-close-btn:hover { color: #333; transform: scale(1.1); }

        .controls-hint { font-size: 0.8rem; text-align: center; color: #888; font-weight: bold; line-height: 1.4; margin-top: 5px; }

        h2 { color: var(--primary-color); border-bottom: 2px solid var(--accent-color); padding-bottom: 8px; font-size: 1.3rem; margin-top: 0; }
        
        .collection-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 15px; }
        .collection-item { display: flex; flex-direction: column; align-items: center; font-size: 0.85rem; font-weight: bold; color: #555; }
        .collection-canvas { width: 60px; height: 60px; margin-bottom: 5px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1)); }
        @media (max-width: 400px) { .collection-grid { grid-template-columns: repeat(3, 1fr); } }

        footer { position: absolute; bottom: 15px; width: 100%; text-align: center; z-index: 10; font-size: 0.8rem; color: #888; pointer-events: auto; }
        footer a { color: var(--primary-color); text-decoration: none; border-bottom: 1px solid; }
    </style>
</head>
<body>

    <canvas id="mascotCanvas"></canvas>

    <div class="ui-layer">
        <div class="logo-title"><h1>Desktop Mascot</h1></div>
        <div class="button-grid">
            <button class="btn btn-game" onclick="openGame()">üéÆ „Ç≤„Éº„É†Â∫ÉÂ†¥ÔºàÈÄ≤Âåñ„Ç≠„É•„Éº„ÉñÔºâ</button>
            <button class="btn" onclick="openModal('howToUseModal')">üìñ ‰ΩøÁî®ÊñπÊ≥ï</button>
            
            <a href="terms.html" target="_blank" class="btn">üìú Âà©Áî®Ë¶èÁ¥Ñ</a>
            <a href="privacy.html" target="_blank" class="btn">üîí „Éó„É©„Ç§„Éê„Ç∑„Éº</a>
            
            <button class="btn" onclick="openModal('downloadModal')">üì• „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ</button>
        </div>
    </div>

    <footer>made by Jumu Tinora(DSKR) | <a href="https://dskr-home.vercel.app/#home" target="_blank">„Çµ„Éº„ÇØ„É´ÂÖ¨ÂºèHP</a></footer>

    <div id="gameModal" class="modal">
        <div class="modal-content">
            <div class="game-ui">
                <div>
                    <button class="rule-btn" onclick="alert('„Äê„É´„Éº„É´„Äë\nÂêå„ÅòÁ®ÆÈ°û„Çí„Åè„Å£„Å§„Åë„Å¶ÈÄ≤ÂåñÔºÅ\nÊúÄÂ§ß„Çµ„Ç§„Ç∫„Çí2„Å§„Åè„Å£„Å§„Åë„Çã„Å®„ÄÅÊ∂àÊªÖ„Åó„Å¶1000ÁÇπ„Éú„Éº„Éä„ÇπÔºÅ\n„ÄêÊ≥®ÊÑè„ÄëÁ©ç„Åø‰∏ä„Åå„Å£„ÅüÂ≠ê„ÅåËµ§„ÅÑ„É©„Ç§„É≥„Å´Ëß¶„Çå„Çã„Å®„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Åß„Åô„ÄÇ')">„É´„Éº„É´</button>
                    <button class="rule-btn collection-btn" onclick="openCollection()">Âõ≥Èëë</button>
                </div>
                <div class="score-box">SCORE: <span id="scoreVal">0</span></div>
            </div>
            <div id="gameContainer">
                <canvas id="gameCanvas"></canvas>
            </div>
            <button class="game-close-btn" onclick="closeGame()">Ôºû Èñâ„Åò„Çã Ôºú</button>
            <div class="controls-hint">
                PC: [A][D]„Ç≠„Éº„ÅßÁßªÂãï / „ÇØ„É™„ÉÉ„ÇØ„ÅßËêΩ‰∏ã<br>
                „Çπ„Éû„Éõ: „Çø„ÉÉ„Éó„Åó„ÅüÂ†¥ÊâÄ„Å´ËêΩ‰∏ã
            </div>
        </div>
    </div>

    <div id="howToUseModal" class="modal" onclick="closeModalOnOuter(event)"><div class="modal-content"><h2>‰ΩøÁî®ÊñπÊ≥ï</h2><p>DesktopMascot.exe„ÇíËµ∑Âãï„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇËÉåÊôØ„ÅÆÂ≠ê„ÅØ„Éâ„É©„ÉÉ„Ç∞„ÇÑ„ÇØ„É™„ÉÉ„ÇØ„ÅßÈÅä„Åπ„Åæ„Åô„ÄÇ</p><button class="game-close-btn" onclick="closeModal('howToUseModal')">Ôºû Èñâ„Åò„Çã Ôºú</button></div></div>
    <div id="downloadModal" class="modal" onclick="closeModalOnOuter(event)"><div class="modal-content"><h2>„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ</h2><p>ÁèæÂú®Ê∫ñÂÇô‰∏≠„Åß„Åô„ÄÇBOOTH„Åß„ÅÆÂÖ¨Èñã„Çí„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ</p><button class="game-close-btn" onclick="closeModal('downloadModal')">Ôºû Èñâ„Åò„Çã Ôºú</button></div></div>

    <div id="collectionModal" class="modal">
        <div class="modal-content" style="max-width: 440px;">
            <h2>„Éû„Çπ„Ç≥„ÉÉ„ÉàÂõ≥Èëë</h2>
            <p style="font-size: 0.85rem; color: #666; text-align: center; margin-top: -5px; margin-bottom: 5px;">„Ç≤„Éº„É†„ÅßÊñ∞„Åó„ÅèÈÄ≤Âåñ„Åï„Åõ„Çã„Å®Ëß£Êîæ„Åï„Çå„Åæ„Åô„ÄÇ</p>
            <div id="collectionGrid" class="collection-grid"></div>
            <button class="game-close-btn" onclick="closeModal('collectionModal')">Ôºû Èñâ„Åò„Çã Ôºú</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        function openModal(id) { document.getElementById(id).style.display = "flex"; }
        function closeModal(id) { document.getElementById(id).style.display = "none"; }
        function closeModalOnOuter(event) { if (event.target.className === "modal") event.target.style.display = "none"; }
        window.addEventListener('keydown', (e) => { if (e.key === "Escape") document.querySelectorAll('.modal').forEach(m => m.style.display = "none"); });

        function drawFace(ctx, x, y, size, rotation, expr) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(rotation);
            const eyeR = size * 0.08, eyeX = size * 0.2, eyeY = -size * 0.1;
            ctx.fillStyle = "#333"; ctx.strokeStyle = "#333"; ctx.lineWidth = Math.max(1, size * 0.03);
            if (expr === 1) { 
                ctx.beginPath(); ctx.arc(-eyeX, eyeY, eyeR, 0, Math.PI); ctx.stroke();
                ctx.beginPath(); ctx.arc(eyeX, eyeY, eyeR, 0, Math.PI); ctx.stroke();
            } else if (expr === 2) { 
                ctx.fillRect(-eyeX - eyeR, eyeY, eyeR * 2, 1.5); ctx.fillRect(eyeX - eyeR, eyeY, eyeR * 2, 1.5);
                ctx.beginPath(); ctx.arc(0, size * 0.2, eyeR, Math.PI, 0); ctx.stroke();
            } else if (expr === 3) { 
                ctx.font = `bold ${size * 0.25}px Arial`; ctx.fillText("@", -eyeX - eyeR, eyeY + eyeR); ctx.fillText("@", eyeX - eyeR, eyeY + eyeR);
            } else { 
                ctx.beginPath(); ctx.arc(-eyeX, eyeY, eyeR, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(eyeX, eyeY, eyeR, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(0, size * 0.1, eyeR, 0, Math.PI); ctx.stroke();
            }
            ctx.restore();
        }

        const bCanvas = document.getElementById('mascotCanvas');
        const bCtx = bCanvas.getContext('2d');
        let backCubes = [];
        let draggedCube = null;
        let mouseX = 0, mouseY = 0, lastMX = 0, lastMY = 0;
        let isMouseDown = false, dragStartTime = 0, startMX = 0, startMY = 0;

        function bResize() { bCanvas.width = window.innerWidth; bCanvas.height = window.innerHeight; }
        window.addEventListener('resize', bResize); bResize();

        class BackCube {
            constructor() { this.init(); this.y = Math.random() * bCanvas.height; }
            init() {
                this.size = 45 + Math.random() * 40; this.x = Math.random() * bCanvas.width; this.y = -this.size - (Math.random() * 700);
                this.speedY = 0.05 + Math.random() * 0.1; this.speedX = (Math.random() - 0.5) * 0.2;
                this.rotation = Math.random() * 6; this.rotSpeed = (Math.random() - 0.5) * 0.002;
                this.color = ["#87CEEB", "#FFD700", "#FFD1DC", "#E0FFFF", "#FF1493"][Math.floor(Math.random() * 5)];
                this.expr = Math.floor(Math.random() * 4); this.timer = 300 + Math.random() * 500; this.isDragging = false;
            }
            update() {
                if (this.isDragging) {
                    this.x += (mouseX - this.x) * 0.15; this.y += (mouseY - this.y) * 0.15;
                    this.speedX = (mouseX - lastMX) * 0.5; this.speedY = (mouseY - lastMY) * 0.5;
                } else {
                    this.y += this.speedY; this.x += this.speedX; this.rotation += this.rotSpeed;
                    if (this.speedY < 0) this.speedY += 0.3; else { this.speedY += 0.01; if (this.speedY > 0.8) this.speedY = 0.8; }
                    this.timer--; if (this.timer <= 0) { this.expr = Math.floor(Math.random() * 4); this.timer = 300 + Math.random() * 500; }
                    if (this.y > bCanvas.height + this.size) this.init();
                    if (this.x < this.size/2 || this.x > bCanvas.width - this.size/2) { this.speedX *= -0.3; this.x = Math.max(this.size/2, Math.min(bCanvas.width - this.size/2, this.x)); }
                }
            }
            draw() {
                bCtx.save(); bCtx.translate(this.x, this.y); bCtx.rotate(this.rotation);
                if (this.isDragging) { bCtx.shadowBlur = 10; bCtx.shadowColor = "rgba(0,0,0,0.1)"; bCtx.scale(1.05, 1.05); }
                bCtx.fillStyle = this.color; bCtx.strokeStyle = "#333"; bCtx.lineWidth = 1.5;
                bCtx.beginPath(); let r = 8;
                bCtx.moveTo(-this.size/2 + r, -this.size/2); bCtx.arcTo(this.size/2, -this.size/2, this.size/2, this.size/2, r);
                bCtx.arcTo(this.size/2, this.size/2, -this.size/2, this.size/2, r); bCtx.arcTo(-this.size/2, this.size/2, -this.size/2, -this.size/2, r);
                bCtx.arcTo(-this.size/2, -this.size/2, this.size/2, -this.size/2, r); bCtx.fill(); bCtx.stroke(); bCtx.restore();
                drawFace(bCtx, this.x, this.y, this.size, this.rotation, this.expr);
            }
            isHit(mx, my) { return mx > this.x - this.size/2 - 15 && mx < this.x + this.size/2 + 15 && my > this.y - this.size/2 - 15 && my < this.y + this.size/2 + 15; }
            bounce() { this.speedY = -12 - Math.random() * 5; this.speedX = (Math.random() - 0.5) * 10; this.expr = 3; }
        }

        for (let i = 0; i < 20; i++) backCubes.push(new BackCube());

        bCanvas.addEventListener('mousedown', e => {
            const rect = bCanvas.getBoundingClientRect(); startMX = e.clientX - rect.left; startMY = e.clientY - rect.top;
            isMouseDown = true; dragStartTime = Date.now();
            for (let i = backCubes.length - 1; i >= 0; i--) { if (backCubes[i].isHit(startMX, startMY)) { draggedCube = backCubes[i]; break; } }
        });
        window.addEventListener('mousemove', e => {
            const rect = bCanvas.getBoundingClientRect(); lastMX = mouseX; lastMY = mouseY;
            mouseX = e.clientX - rect.left; mouseY = e.clientY - rect.top;
            if (draggedCube && isMouseDown) { if (Math.hypot(mouseX - startMX, mouseY - startMY) > 5) { draggedCube.isDragging = true; bCanvas.style.cursor = "grabbing"; }
            } else { let h = false; backCubes.forEach(c => { if(c.isHit(mouseX, mouseY)) h = true; }); bCanvas.style.cursor = h ? "grab" : "default"; }
        });
        window.addEventListener('mouseup', () => {
            if (draggedCube) { if (!draggedCube.isDragging || (Date.now() - dragStartTime < 250)) { draggedCube.bounce(); } draggedCube.isDragging = false; draggedCube = null; }
            isMouseDown = false; bCanvas.style.cursor = "default";
        });

        function bAnimate() { bCtx.clearRect(0, 0, bCanvas.width, bCanvas.height); backCubes.forEach(c => { c.update(); c.draw(); }); requestAnimationFrame(bAnimate); }
        bAnimate();

        // --- Âõ≥Èëë„Ç∑„Çπ„ÉÜ„É† ---
        const CUBE_TYPES = [
            { size: 25, color: "#E0FFFF", score: 2, expr: 1 }, 
            { size: 40, color: "#87CEEB", score: 4, expr: 0 },
            { size: 55, color: "#FFD1DC", score: 8, expr: 2 }, 
            { size: 75, color: "#FFD700", score: 16, expr: 3 },
            { size: 100, color: "#9370DB", score: 32, expr: 0 }, 
            { size: 130, color: "#32CD32", score: 64, expr: 0 },
            { size: 165, color: "#FF4500", score: 128, expr: 0 },
            { size: 200, color: "#FF1493", score: 256, expr: 3 } 
        ];

        let unlockedCubes = JSON.parse(localStorage.getItem('mascot_collection')) || Array(CUBE_TYPES.length).fill(false);

        function openCollection() { openModal('collectionModal'); drawCollection(); }

        function drawCollection() {
            const grid = document.getElementById('collectionGrid');
            grid.innerHTML = '';
            
            CUBE_TYPES.forEach((type, index) => {
                const isUnlocked = unlockedCubes[index];
                const itemDiv = document.createElement('div');
                itemDiv.className = 'collection-item';
                
                const canvas = document.createElement('canvas');
                canvas.className = 'collection-canvas';
                canvas.width = 120; canvas.height = 120;
                const ctx = canvas.getContext('2d');
                const size = 80; const x = 60; const y = 60;
                
                ctx.save(); ctx.translate(x, y); ctx.lineWidth = 4;
                if (isUnlocked) {
                    ctx.fillStyle = type.color; ctx.strokeStyle = "#333"; ctx.beginPath(); 
                    let r = 15;
                    ctx.moveTo(-size/2 + r, -size/2); ctx.arcTo(size/2, -size/2, size/2, size/2, r);
                    ctx.arcTo(size/2, size/2, -size/2, size/2, r); ctx.arcTo(-size/2, size/2, -size/2, -size/2, r);
                    ctx.arcTo(-size/2, -size/2, size/2, -size/2, r); ctx.fill(); ctx.stroke();
                    drawFace(ctx, 0, 0, size, 0, type.expr);
                } else {
                    ctx.fillStyle = "#e0e0e0"; ctx.strokeStyle = "#aaa"; ctx.beginPath(); 
                    let r = 15;
                    ctx.moveTo(-size/2 + r, -size/2); ctx.arcTo(size/2, -size/2, size/2, size/2, r);
                    ctx.arcTo(size/2, size/2, -size/2, size/2, r); ctx.arcTo(-size/2, size/2, -size/2, -size/2, r);
                    ctx.arcTo(-size/2, -size/2, size/2, -size/2, r); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = "#aaa"; ctx.font = "bold 50px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("?", 0, 5);
                }
                ctx.restore();
                itemDiv.appendChild(canvas);
                const label = document.createElement('span');
                label.innerText = isUnlocked ? `Lv.${index + 1}` : "???";
                itemDiv.appendChild(label);
                grid.appendChild(itemDiv);
            });
        }

        // --- „Éü„Éã„Ç≤„Éº„É† ---
        let engine, render, runner;
        let gameActive = false, currentCube = null, score = 0;
        let isGameInitialized = false; 
        const gameWidth = 360, gameHeight = 500;
        const DEAD_LINE_Y = 100; const SPAWN_Y = 30;      

        function openGame() { 
            document.getElementById('gameModal').style.display = "flex"; 
            if (!isGameInitialized) { initGame(); isGameInitialized = true; } 
            else { Matter.Runner.run(runner, engine); resetGame(); }
        }
        
        function closeGame() { 
            document.getElementById('gameModal').style.display = "none"; gameActive = false;
            if (runner) Matter.Runner.stop(runner); 
        }

        function initGame() {
            const { Engine, Render, Runner, World, Bodies, Events, Body } = Matter;
            engine = Engine.create();
            const container = document.getElementById('gameContainer'), gCanvas = document.getElementById('gameCanvas');
            gCanvas.width = gameWidth; gCanvas.height = gameHeight;
            render = Render.create({ element: container, engine: engine, canvas: gCanvas, options: { width: gameWidth, height: gameHeight, wireframes: false, background: '#ffffff' } });
            
            runner = Runner.create(); Runner.run(runner, engine); Render.run(render);

            Events.on(engine, 'collisionStart', (event) => {
                event.pairs.forEach((pair) => {
                    const { bodyA, bodyB } = pair;
                    if (bodyA.label && bodyA.label === bodyB.label && bodyA.label.startsWith('c_')) {
                        const idx = parseInt(bodyA.label.split('_')[1]);
                        
                        if (idx < CUBE_TYPES.length - 1) {
                            const midX = (bodyA.position.x + bodyB.position.x) / 2;
                            const midY = (bodyA.position.y + bodyB.position.y) / 2;
                            World.remove(engine.world, [bodyA, bodyB]);
                            spawnCube(midX, midY, idx + 1, false); 
                            score += CUBE_TYPES[idx+1].score; 
                            document.getElementById('scoreVal').innerText = score;
                        } else {
                            bodyA.label = 'merged'; bodyB.label = 'merged';
                            score += 1000; document.getElementById('scoreVal').innerText = score;
                            Body.setStatic(bodyA, true); Body.setStatic(bodyB, true);
                            bodyA.render.opacity = 0.5; bodyB.render.opacity = 0.5;
                            setTimeout(() => { Matter.World.remove(engine.world, [bodyA, bodyB]); }, 1200);
                        }
                    }
                });
            });

            Events.on(engine, 'afterUpdate', () => {
                if (!gameActive) return;
                engine.world.bodies.forEach(body => { 
                    if (!body.isStatic && body.label && body.label.startsWith('c_') && body !== currentCube) {
                        if (body.bounds.min.y <= DEAD_LINE_Y) {
                            if (Math.abs(body.velocity.y) < 0.5 && Math.abs(body.velocity.x) < 0.5) {
                                body.restCounter = (body.restCounter || 0) + 1;
                                if (body.restCounter > 10) { 
                                    gameActive = false; 
                                    setTimeout(() => { alert("GAME OVER! SCORE: " + score); closeGame(); }, 500);
                                }
                            } else { body.restCounter = 0; }
                        } else { body.restCounter = 0; }
                    } 
                });
            });

            Events.on(render, 'afterRender', () => {
                const c = gCanvas.getContext('2d');
                c.strokeStyle = 'rgba(255, 0, 0, 0.8)'; c.setLineDash([8, 6]); c.lineWidth = 3;
                c.beginPath(); c.moveTo(-100, DEAD_LINE_Y); c.lineTo(gameWidth + 100, DEAD_LINE_Y); c.stroke(); c.setLineDash([]);
                
                engine.world.bodies.forEach(body => {
                    if (body.label && (body.label.startsWith('c_') || body.label === 'merged')) {
                        const labelParts = body.label === 'merged' ? ['c', CUBE_TYPES.length - 1] : body.label.split('_');
                        const idx = parseInt(labelParts[1]);
                        c.globalAlpha = body.render.opacity || 1; 
                        drawFace(c, body.position.x, body.position.y, CUBE_TYPES[idx].size, body.angle, CUBE_TYPES[idx].expr);
                        c.globalAlpha = 1; 
                    }
                });
            });

            resetGame();

            container.addEventListener('mousedown', (e) => { 
                if(!gameActive || !currentCube || !currentCube.isStatic) return;
                const rect = container.getBoundingClientRect();
                const mx = (e.clientX - rect.left) * (gameWidth / rect.width);
                Body.setPosition(currentCube, { x: Math.max(25, Math.min(gameWidth-25, mx)), y: SPAWN_Y });
                Body.setStatic(currentCube, false); currentCube = null; setTimeout(() => { if(gameActive) createNextCube(); }, 900);
            });

            window.addEventListener('keydown', (e) => {
                if (!gameActive || !currentCube || !currentCube.isStatic) return;
                if (e.key === 'a' || e.key === 'ArrowLeft') { Body.setPosition(currentCube, { x: Math.max(25, Math.min(gameWidth - 25, currentCube.position.x - 20)), y: SPAWN_Y }); }
                if (e.key === 'd' || e.key === 'ArrowRight') { Body.setPosition(currentCube, { x: Math.max(25, Math.min(gameWidth - 25, currentCube.position.x + 20)), y: SPAWN_Y }); }
                if (e.key === ' ') { Body.setStatic(currentCube, false); currentCube = null; setTimeout(() => { if(gameActive) createNextCube(); }, 900); }
            });

            container.addEventListener('touchstart', (e) => {
                e.preventDefault(); if(!gameActive || !currentCube || !currentCube.isStatic) return;
                const rect = container.getBoundingClientRect();
                const tx = (e.touches[0].clientX - rect.left) * (gameWidth / rect.width);
                Body.setPosition(currentCube, { x: Math.max(25, Math.min(gameWidth-25, tx)), y: SPAWN_Y });
                Body.setStatic(currentCube, false); currentCube = null; setTimeout(() => { if(gameActive) createNextCube(); }, 900);
            });
        }

        function createNextCube() { 
            if (!gameActive) return; 
            const idx = Math.floor(Math.random() * 3); 
            currentCube = spawnCube(gameWidth/2, SPAWN_Y, idx, true); 
        }
        
        function spawnCube(x, y, index, isStatic) {
            const type = CUBE_TYPES[index];
            const cube = Matter.Bodies.rectangle(x, y, type.size, type.size, { friction: 0.3, restitution: 0.1, label: 'c_' + index, isStatic: isStatic, render: { fillStyle: type.color, strokeStyle: '#333', lineWidth: 2, opacity: 1 } });
            Matter.World.add(engine.world, cube); 
            
            if (!unlockedCubes[index]) {
                unlockedCubes[index] = true;
                localStorage.setItem('mascot_collection', JSON.stringify(unlockedCubes));
            }
            
            return cube;
        }
        
        function resetGame() {
            if(!engine) return;
            Matter.World.clear(engine.world, false); 
            Matter.World.add(engine.world, [
                Matter.Bodies.rectangle(gameWidth/2, gameHeight + 25, gameWidth, 50, { isStatic: true, render: { fillStyle: '#333' } }),
                Matter.Bodies.rectangle(-25, gameHeight/2, 50, gameHeight, { isStatic: true, render: { fillStyle: '#333' } }),
                Matter.Bodies.rectangle(gameWidth + 25, gameHeight/2, 50, gameHeight, { isStatic: true, render: { fillStyle: '#333' } })
            ]);
            score = 0; document.getElementById('scoreVal').innerText = score; 
            gameActive = true; 
            setTimeout(createNextCube, 200);
        }
    </script>
</body>
</html>
